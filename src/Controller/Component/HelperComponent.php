<?php
namespace App\Controller\Component;

use Cake\Controller\Component;
use Cake\ORM\TableRegistry;
use Cake\Network\Http\Client;
use Cake\Core\Configure;

class HelperComponent extends Component
{

  public function initialize(array $config) {
    if (Configure::read('debug') === true) {
      $this->apinsUrl = 'https://api-ns-staging.mousebiology.org';
    } else {
      $this->apinsUrl = 'https://api-ns.mousebiology.org';
    }
  }


  /* Save project relations in the Api-NS middleware */
  public function saveRelationsToApins($array) {
    $http = new Client();
    return $http->post(
      $this->apinsUrl.'/save-relations',
      json_encode($array),
      ['redirect' => 999]
      );
  }


  /* Prepares a custom list to use in form dropdowns */
  public function prepareViewList($tableName, $columns, $delimiter=null) {
    $delimiter = isset($delimiter) ? $delimiter : ' ';
    $table = TableRegistry::get($tableName);
    $query = $table->find('all');      
    $res = [];
    foreach ($query as $row) {
      $shownValue = '';
      if (is_string($columns)) {
        $shownValue = $row[$columns];       
      }
      if (is_array($columns)) { //Concat columns into a single string separated by blank space
        foreach ($columns as $column) {
          $shownValue .= $row[$column] . $delimiter;       
        }
      }
      $res[$row['id']] = rtrim($shownValue, $delimiter); //remove last delimiter
    }
    return $res;
  }


    /**
     * A method to retrieve descendants of a parent from a multi-level array produced 
     * by find('threaded')
     *
     * @param array $arr An array produced by find('threaded')
     * @param int $parentId The id of a parent the children of which are to be returned
     * @return array Nested array containig only the children/grandchildren/etc of a given parent. The parent is not included in the result set.
     */
    public function getChildrenFor($arr, $parentId) {
      $results = array();
      foreach ($arr as $el) {
        if ($el['parent_id'] === $parentId) { //we have a child
          $results[] = $el; //add the child to the result set
        }
        //if the child has children recursively get its descendants 
        if (count($el['children']) > 0 && ($children = $this->getChildrenFor($el['children'], $parentId)) !== FALSE) {
          $results = array_merge($results, $children); //add children to the result set
        }
      }
      return count($results) > 0 ? $results : FALSE;
    }


    /**
     * A method to retrieve parents for a given container ID 
     *
     * @param int $childId The id of a child parents of which are to be returned
     * @param int $containersArr The array of containers generated by $this->InventoryContainers->find('all') and REINDEXED so that array index = container id
     * @return array Flat array containig only the parents of a given child. The child is NOT included.
     */
    public function getContainerParents($childId, $containersArr) {
      $thisMethodName = __FUNCTION__;
      $parentIdToLookFor = $containersArr[$childId]['parent_id'];
      /* Find a parent */
      foreach ($containersArr as $el) {
        if ($el->id == $parentIdToLookFor) {
          $foundParent =  $el;
          break;
        }
      }
      /* Parent found! */
      if (isset($foundParent)) {
        $parents[] = $foundParent;
        /* Now recursively look for other parents */
        if ( ($parent = $this->$thisMethodName($foundParent->id, $containersArr)) !== FALSE ) {
          return array_merge($parents, (array) $parent);
        }
      } 
    }
    
    
    /**
     * A method to retrieve descendants of a parent from a multi-level array produced 
     * by find('threaded')
     *
     * @param array $data An array produced by find('threaded')
     * @return 2 dimensional array contains a dictionary using the $data[id] attribute. Using the id as the key, you can retrieve all children as array
     */
    public function getAncestors($data){
      /*Grab all containers*/
      $c_array = $data;
      $ancestry_ds = array();
      foreach ($c_array as $child)
      {
       $ancestry_ds[$child->id] = array();
           //if an immediate parent exists, go ahead. No, skip
       if($child->parent_id !== NULL)
       { 
        $current_parent = $child->parent_id;
        while($current_parent !== NULL)
        {
          //search array for a matching parent_id
          //Using a non-php variant of array_column here
          $c_array_key = array_search($current_parent, $this->array_column_nonstandard($c_array, 'id'));
                    //found one, now add to array
          if($ancestry_ds[$child->id] === 12)
          {
            echo $c_array_key;
          }
          array_push($ancestry_ds[$child->id], $c_array[$c_array_key]);
                    //move up one level now
          $current_parent = $c_array[$c_array_key]['parent_id'];
        }   
      }
    }
    return (array) $ancestry_ds;
  }//end

    /**
     * A method to simulate array_column function of a higher PHP version. 
     * According to documentations, it should be available here but it isn't. 
     * Switching it to the standard array_column just requires renaming
    
     * @param array $input multidimensional array
     * @param $columnKey name of key for the associative array
     * @param $indexKey specific id to search
     * @return an array containing values of the specific key at the first level of the array
     */
    public function array_column_nonstandard(array $input, $columnKey, $indexKey = null)
    {
     $array = array();
     foreach ($input as $value) {
      if ( ! isset($value[$columnKey])) {
        trigger_error("Key \"$columnKey\" does not exist in array");
        return false;
      }
      if (is_null($indexKey)) {
        $array[] = $value[$columnKey];
      } else {
        if ( ! isset($value[$indexKey])) {
          trigger_error("Key \"$indexKey\" does not exist in array");
          return false;
        }
        if ( ! is_scalar($value[$indexKey])) {
          trigger_error("Key \"$indexKey\" does not contain scalar value");
          return false;
        }
        $array[$value[$indexKey]] = $value[$columnKey];
      }
    }
    return $array;
  }

    /**
     * A method to retrieve an array of ALL vials (shipped included) associated with either SC or EC.
     * The method returns both active vials and shipped vials.
     * @param $spermCryoId the ID of sperm cryo
     * @param $embryoCryoId the ID of embryo cryo
     * @return an array containing vial information
     */
    public function getAllVials($spermCryoId = null, $embryoCryoId = null) {
      //Get vials
      $table = TableRegistry::get('inventory_vials');
      $inventoryVialsArr = $table->find('all', ['contain' => ['InventoryVialTypes', 
        'InventoryLocations' => [
        'InventoryBoxes' => [
        'InventoryBoxTypes', 'InventoryContainers'
        ] 
        ]
        ]])
      ->where([
        'OR' => [['sperm_cryo_id' => $spermCryoId], ['embryo_cryo_id' => $embryoCryoId]],
        ])->toArray();

      //Get shipped vials
      $table = TableRegistry::get('inventory_shipped_vials');
      $inventoryShippedVialsArr = $table->find('all')
      ->where([
        'OR' => [['sperm_cryo_id' => $spermCryoId], ['embryo_cryo_id' => $embryoCryoId]],
        ])->toArray();
      $allVialsArr = array_merge($inventoryVialsArr, $inventoryShippedVialsArr);
      return $allVialsArr;
    }

    /**
     * A method to reindex an array of arrays so that
     * array index equals a row id. For faster lookups.
     * @param array $array returned by find('all')
     * @return reindexed array
     */
    public function reindexArr($array) {
      if (!is_array($array)) throw new \Exception(__FUNCTION__ .'() method expects array as its argument. '.ucwords(gettype($array)).' given.');
      $newArr = [];
      foreach ($array as $entry) {
        if (!isset($entry->id)) {
            continue; //skip if there's no id in a given entry
          }
          $newArr[$entry->id] = $entry;
        }
        return $newArr;
      }
    }